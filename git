#!/usr/bin/python3
# A "Facade" in front of git for some safety measures and additional features.
from __future__ import annotations

import re
import subprocess
import sys
from typing import List, Optional

from colored import fg
from tealprint import TealPrint


def main() -> None:
    create_extras()

    if is_empty_command():
        run_git(sys.argv)
        return

    # Extra functionality
    extra = ExtraFunctionality.get_extra(sys.argv)
    if extra:
        extra.run(sys.argv)

    # Run full command
    if not extra or extra.run_default:
        run_git(sys.argv)


def is_empty_command() -> bool:
    return len(sys.argv) <= 1


def run_git(cmd: List[str], capture_output=False) -> str:
    # Get platform dependent path/binary
    if sys.platform == "win32":
        cmd[0] = "git.exe"
    elif sys.platform == "linux":
        cmd[0] = "/usr/bin/git"

    result = subprocess.run(cmd, capture_output=capture_output)
    if result:
        if capture_output:
            return str(result.stdout)
        elif result.returncode != 0:
            sys.exit(result.returncode)
    return ""


def create_extras() -> None:
    Checkout()
    CheckoutFromMain()
    CommitAll()
    PruneLocalBranches()
    Push()
    ForwardCommand(["rebase", "branch"], "git-rebase-branch", False)
    ForwardCommand(["hook"], "git-hook", False)
    ForwardCommand(["release"], "git-release", False)


class ExtraFunctionality:
    extras: List[ExtraFunctionality] = []

    def __init__(self, command: List[str], run_default: bool) -> None:
        self.command = command
        self.run_default = run_default
        ExtraFunctionality.extras.append(self)

    def should_run(self, cmd: List[str]) -> bool:
        if len(cmd) - 1 < len(self.command):
            return False

        for i in range(len(self.command)):
            if cmd[i + 1] != self.command[i]:
                return False

        return True

    def run(self, cmd: List[str]) -> None:
        pass

    @staticmethod
    def get_extra(cmd: List[str]) -> Optional[ExtraFunctionality]:
        for extra in ExtraFunctionality.extras:
            if extra.should_run(cmd):
                return extra


class Checkout(ExtraFunctionality):
    def __init__(self) -> None:
        super().__init__(["checkout", "-b"], run_default=True)

    def run(self, cmd: List[str]) -> None:
        TealPrint.info("Pulling before checkout out a new branch", color=fg("green"))
        run_git(["git", "pull"])


class CheckoutFromMain(ExtraFunctionality):
    def __init__(self) -> None:
        super().__init__(["checkout", "-m"], run_default=False)

    def run(self, cmd: List[str]) -> None:
        TealPrint.info("Checking out from main", color=fg("green"))
        run_git(["git", "checkout", "main"])
        cmd[2] = "-b"
        subprocess.run(cmd)


class ForwardCommand(ExtraFunctionality):
    def __init__(self, command: List[str], to_run: str, run_default: bool) -> None:
        super().__init__(command, run_default)
        self.to_run = to_run

    def run(self, cmd: List[str]) -> None:
        command = self.compose_cmd(cmd)
        subprocess.run(command)

    def compose_cmd(self, cmd: List[str]) -> List[str]:
        command = [self.to_run]

        for i in range(len(self.command) + 1, len(cmd)):
            command.append(cmd[i])

        return command


class PruneLocalBranches(ExtraFunctionality):
    def __init__(self) -> None:
        super().__init__(["prune", "branches"], run_default=False)

    def run(self, cmd: List[str]) -> None:
        to_prune = self.get_local_branches_not_on_remote()

        for branch in to_prune:
            run_git(["git", "branch", "-D", branch])

    def get_local_branches_not_on_remote(self) -> List[str]:
        run_git(["git", "fetch", "-p"], capture_output=True)
        out = run_git(["git", "branch", "-vv"], capture_output=True)

        # Origin that are gone
        pattern = re.compile(r"([\w\d\-_\.]+)\s+[a-f0-9]+\s(?:(?!\[origin)|\[origin\/[\/\w\d\-_\.]+: gone)")
        matches = re.findall(pattern, out)
        print(f"{matches}")
        return matches


class CommitAll(ExtraFunctionality):
    def __init__(self) -> None:
        super().__init__(["ca"], run_default=False)

    def run(self, cmd: List[str]) -> None:
        # Add all files to staging
        run_git(["git", "add", "--all"])

        # Remove first arguments (including optional -m)
        cmdExt = cmd[2:]
        if len(cmdExt) > 0 and cmdExt[0] == "-m":
            cmdExt.pop(0)

        # Commit all files
        cmd = ["git", "commit", "-m"]
        cmd.extend(cmdExt)
        run_git(cmd)


class Push(ExtraFunctionality):
    """Automatically sets updstream if not set"""

    def __init__(self) -> None:
        super().__init__(["push"], run_default=True)

    def run(self, cmd: List[str]) -> None:
        out = run_git(["git", "status", "-b", "--porcelain=v2"], capture_output=True)
        if "upstream" not in out:
            TealPrint.info("Automatically setting upstream", color=fg("green"))
            run_git(["git", "push", "--set-upstream", "origin", "HEAD"])


main()
