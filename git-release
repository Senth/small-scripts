#!/bin/bash

print_usage_and_exit() {
  echo "Requires one parameter. Will tag this repo and all submodules as well"
  echo "usage: release [major|minor|patch]"
  exit 1
}

if [ $# != 1 ]; then
  print_usage_and_exit
elif ! [[ "$1" == "major" || "$1" == "minor" || "$1" == "bugfix" || "$1" == "patch" ]]; then
  print_usage_and_exit
fi

# Special case if package.json exists
if [ -f "package.json" ]; then
  option=$1
  if [[ "$option" == "bugfix" ]]; then
    option="patch"
  fi

  yarn version "--$option" && git push && git push --tags
  exit 0
fi

type=$1

git fetch

current_version=`git tag | sed 's/^\(v?.*\)/\1/' | sort -V | tail -1`
if [[ "$current_version" =~ (v?)([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
  v_prefix=${BASH_REMATCH[1]}
  next_major=${BASH_REMATCH[2]}
  next_minor=${BASH_REMATCH[3]}
  next_patch=${BASH_REMATCH[4]}
elif [[ "$current_version" == "" ]]; then
  next_major=0
  next_minor=0
  next_patch=0
  echo "First version! :)"
else 
  echo "Unable to parse $current_version"
  exit 1
fi


# Create next version
if [ "$type" = "major" ]; then
  next_major=$((next_major + 1))
  next_minor=0
  next_patch=0
elif [ "$type" = "minor" ]; then
  next_minor=$((next_minor + 1))
  next_patch=0
elif [[ "$type" == "bugfix" || "$type" == "patch" ]]; then
  next_patch=$((next_patch + 1))
fi
next_version=$v_prefix$next_major.$next_minor.$next_patch

echo "$current_version -> $next_version"

# Tag with new version
git checkout main && git pull && git tag "$next_version" && git push --tags
# git remote prune origin
